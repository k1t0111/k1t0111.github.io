---
title: "类"
date: "2024-09-17"
description: "!"
---

!![image.png](https://raw.githubusercontent.com/k1t0111/blog/main/image/20240917153744.png)

### [](#包（Package） "包（Package）")包（Package）

包是用来组织和管理Java类的一种机制。它提供了命名空间，使得不同的类可以归类到不同的包中。在Java中，每个类都必须声明所属的包，或者如果没有声明，默认属于无名（unnamed）包。

### [](#访问修饰符（Access-Modifiers） "访问修饰符（Access Modifiers）")访问修饰符（Access Modifiers）

Java中有几种访问修饰符，用于控制类、方法和变量的可见性和访问权限：

1.  **public**：公共的，可以被任何其他类访问。
2.  **protected**：受保护的，可以被同一包内的类以及子类访问。
3.  **default**（或称为包私有，package-private）：默认的，没有修饰符，只能被同一包内的类访问。
4.  **private**：私有的，只能被当前类内部访问，其他任何类都不能访问。

### [](#访问控制详解 "访问控制详解")访问控制详解

现在来解释包和访问控制之间的关系：

*   如果一个类没有指定任何访问修饰符（即使用默认的包私有修饰符），它只能被同一个包中的其他类访问，而不能被其他包的类访问。
    
*   如果一个类被声明为 `public`，那么它可以被任何其他类访问，无论这些类是否在同一个包中。
    
*   如果一个类被声明为 `protected`，那么它可以被同一个包中的其他类访问，以及其他包中的继承了该类的子类访问。
    
*   如果一个类被声明为 `private`，那么它只能被定义该类的源文件内的其他类访问，其他任何地方都不能访问。
    
*   对于成员变量和方法，同样的规则适用：它们的访问级别也受到类的访问级别和访问修饰符的限制。
    

### [](#例子解释 "例子解释")例子解释

假设有如下的类定义：

javaCopy Code

```java
package org.example;public class MyClass {    private int privateVar;     int defaultVar;     protected int protectedVar;     public int publicVar; private void privateMethod() {// 只能在 MyClass 内部访问 } void defaultMethod() { // 只能在 org.example 包内访问 } protected void protectedMethod() { // 可以在 org.example 包内及其子类中访问 }public void publicMethod() { // 可以被任何地方访问 } }
```

在上面的例子中：

*   `privateVar` 和 `privateMethod()` 只能在 `MyClass` 内部访问，其他任何类都无法访问它们。
*   `defaultVar` 和 `defaultMethod()` 可以在 `org.example` 包内的任何类访问，但是不能在该包外的类访问。
*   `protectedVar` 和 `protectedMethod()` 可以在 `org.example` 包内的任何类访问，同时也可以在继承 `MyClass` 的子类中访问，无论这些子类是否在同一个包中。
*   `publicVar` 和 `publicMethod()` 可以被任何地方的任何类访问。

#### [](#java访问策略 "java访问策略")java访问策略

### [](#1-private "1. private")1. `private`

*   **定义**：`private` 修饰符用于限制对变量或方法的访问，仅限于声明它们的类内部。
    
*   **访问**：只能在声明它的类内部访问，外部类或包无法访问。
    
*   **例子**：
    
    javaCopy Code
    
    `private int privateVar; // 只能在 MyClass 内部访问 private void privateMethod() { // 只能在 MyClass 内部调用 }`
    

### [](#2-默认（包内可见） "2. 默认（包内可见）")2\. 默认（包内可见）

*   **定义**：当没有显式指定访问修饰符时，变量或方法具有默认访问权限。
    
*   **访问**：只能在同一个包内的类中访问，包外的类无法访问。
    
*   **例子**：
    
    javaCopy Code
    
    `int defaultVar; // 只能在 org.example 包内访问 void defaultMethod() { // 只能在 org.example 包内调用 }`
    

### [](#3-protected "3. protected")3. `protected`

*   **定义**：`protected` 修饰符允许对变量或方法的访问有更多的灵活性。
    
*   **访问**：
    
    *   可以在同一个包内的类中访问。
    *   可以在任何继承了该类的子类中访问，即使这些子类在不同的包中。
*   **例子**：
    
    javaCopy Code
    
    `protected int protectedVar; // 可以在 org.example 包内及其子类中访问 protected void protectedMethod() { // 可以在 org.example 包内及其子类中调用 }`
    

### [](#4-public "4. public")4. `public`

*   **定义**：`public` 修饰符是最开放的访问级别。
    
*   **访问**：可以在任何地方访问，不受包或类的限制。
    
*   **例子**：
    
    javaCopy Code
    
    `public int publicVar; // 可以被任何地方访问 public void publicMethod() { // 可以被任何地方调用 }`
    

#### [](#公有类 "公有类")公有类

*   一个.java文件中可以包含多个类，但只能有一个类声明为`public`。
*   这个`public`类的类名必须与文件名相同，并且这个类可以包含一个主方法 `main`。
*   `main`方法的签名必须是 `public static void main(String[] args)`，这是Java程序的入口点。
*   如果一个项目中有多个`public`类，并且每个`public`类都包含了`main`方法，那么你可以选择在运行时指定哪个类作为程序的入口。

#### [](#import-语句 "import 语句")import 语句

*   一个Java源文件（.java文件）可以包含多个类，但只能有一个类声明为`public`。
*   这个`public`类的类名必须与文件名相同。
*   当你使用`import`语句时，只能导入这个Java文件中声明的`public`类。  
    `import`语句的作用是为了方便引用其他包中的类，无论这些类是`public`还是非`public`。

### [](#包概念 "包概念")包概念

1.  **每个Java文件只能有一个`package`语句**：这是Java语法规定的，每个Java文件只能声明一次`package`，并且必须在文件的开头非注释部分出现。
    
2.  **一个包可以有多个Java文件**：一个包（如`org.example`）可以包含多个Java文件，每个文件中可以有一个或多个类，但只能有一个`public`类，并且这个类的类名必须与文件名相同。
    
3.  **导入语句的使用**：导入语句（`import`）可以在Java文件的任何位置使用，但通常会放在`package`语句之后，类定义之前。导入语句用于引入其他包中的类，让你可以在当前文件中使用这些类而不需要完整的类路径。
    

所以针对于java来讲，我们的类是一种一个java文件里面一个public类。但是可以在一个包中拥有多个java文件。可以在protected 和public 和默认三种控制权限下访问。

*   **在同一个包内**，可以直接使用其他类，无需 `import`。 非public也可以
*   **在不同包**，必须使用 `import` 语句引入需要的类。
*   **导入静态成员** 也需要 `import` 语句。

### [](#魔术方法 "魔术方法")魔术方法

##### [](#构造函数 "构造函数")构造函数

构造函数跟类有相同的命名，在new一个对象时候运行执行。

```java
import java.io.IOException;public class Exp {    public Exp(){        try {            Runtime.getRuntime().exec("calc.exe");        } catch (IOException e) {            e.printStackTrace();        }    }    public static void main(String[] args) {        Exp exploit = new Exp();    }}
```
