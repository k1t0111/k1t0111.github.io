---
title: "文件上传-php"
date: "2024-09-18"
description: ""
---

![image.png](https://raw.githubusercontent.com/k1t0111/blog/main/image/20240611204655.png)

### [](#查找方式 "查找方式")查找方式

\*\*\*(1) 黑盒 查找(upload) 扫描  
(2) 应用型 窗口 上传中心或者后台中心 上传     Ps:后台是后台 权限是权限  
(3) 会员中心  
(4) 白盒

#### [](#基本函数定义-写前端的 "基本函数定义 写前端的")基本函数定义 写前端的

```php
Enctype 上传类型Method 提交方式Onsubmit 鼠标的时间Action="放在指定文件"Php 接受表单数据 isset()函数 是查看有没有点击 提交Trim()  将字符串的 两边的空格 去除掉    替换成空 Strrchr(语句字符串,'.')  意思就是 从.开始断开 输出 .后的语句Strtolower() 转换小写Str_ireplace('指定字符','',指定字符串)将指定字符串里面的字符转换为空格Array()  是一个数组In_array('字符串','数组')  判断字符串是不是在数组中
```

#### [](#文件上传代码 "文件上传代码:")文件上传代码:

```php
在PHP中上传一个文件建一个表单要比ASP中灵活得多。具体的看代码。如： 代码如下:<form enctype="multipart/form-data" action="upload.php" method="post"> <input type="hidden" name="MAX_FILE_SIZE" value="1000"> <input name="myFile" type="file"> <input type="submit" value="上传文件"> </form> $_FILES $_POST $_GET 等函数获取表单内容。 今天我们着重讲$_FILES函数。  当客户端提交后，我们获得了一个$_FILES 数组 $_FILES数组内容如下: $_FILES['myFile']['name'] 客户端文件的原名称。 $_FILES['myFile']['type'] 文件的 MIME 类型，需要浏览器提供该信息的支持，例如"image/gif"。 $_FILES['myFile']['size'] 已上传文件的大小，单位为字节。 $_FILES['myFile']['tmp_name'] 文件被上传后在服务端储存的临时文件名，一般是系统默认。可以在php.ini的upload_tmp_dir 指定，但 用 putenv() 函数设置是不起作用的。 $_FILES['myFile']['error'] 和该文件上传相关的错误代码。['error'] 是在 PHP 4.2.0 版本中增加的。下面是它的说明：(它们在PHP3.0以后成了常量) UPLOAD_ERR_OK 值：0; 没有错误发生，文件上传成功。 UPLOAD_ERR_INI_SIZE 值：1; 上传的文件超过了 php.ini 中 upload_max_filesize 选项限制的值。 UPLOAD_ERR_FORM_SIZE 值：2; 上传文件的大小超过了 HTML 表单中 MAX_FILE_SIZE 选项指定的值。 UPLOAD_ERR_PARTIAL 值：3; 文件只有部分被上传。 UPLOAD_ERR_NO_FILE 值：4; 没有文件被上传。 值：5; 上传文件大小为0. 
```

文件被上传结束后，默认地被存储在了临时目录中，这时您必须将它从临时目录中删除或移动到其它地方，如果没有，则会被删除。也就是不管是否上传成功，脚本执行完后临时目录里的文件肯定会被删除。所以在删除之前要用PHP的 copy() 函数将它复制到其它位置，此时，才算完成了上传文件过程。

 可以看到这个文件上传的机制 没有type的是相当于post传参有type的是\*\*\*\*$FILE上传的文件  

## [](#绕过 "绕过")绕过

### [](#前端过滤 "前端过滤:")前端过滤:

1.删除掉前端过滤代码

2.禁用js (一般不推荐)

3.抓包修改 (ps:但是禁用之后可能就无法抓到数据包，例如只用js代码 只在前端保存)

##### [](#mime类型 "mime类型")mime类型

Image/gif            

.html文件  text/html

 .xml文件  text/xml

 .png文件  image/png

 .jpeg/.jpg image/jpeg

 .gif           image/gif   

\*\*mime类型其实就是 检查文件头

Getimagesize()函数   读取图像的信息 如果这种

### [](#黑名单 "黑名单")黑名单

黑名单 :   一些脚本文件绝对不允许上传的     
白名单 :相对应的 文件才能

如果黑名单内部并没有搞到  Php5 或者phtml文件后缀 那么就可以通过这种后缀名字来 绕过但是还是要考虑中间件是否支持  
\*\*保证在httpd.conf 中保证他可以解析

*   .php
*   .php3
*   .php4
*   .php5
*   .phtml
*   php1
*   php2

##### [](#后缀名的大小写验证 "后缀名的大小写验证")后缀名的大小写验证

##### [](#后缀强制 "后缀强制")后缀强制

有时候文件上传时候其实 后缀名加上    /.  或者 直接加一个 .  不影响木马后缀

##### [](#如果源码没有过滤空格的话 "如果源码没有过滤空格的话")如果源码没有过滤空格的话

那么可以 在数据包将空格放在后缀名的后面  那么系统就会识别.php空格

格式匹配就会有绕过

##### [](#双写 "双写")双写

##### [](#不过滤-‘-’ "不过滤  ‘.’")不过滤  ‘.’

##### [](#DATA-windows-php "::$DATA **windows php")::$DATA \*\*windows php

    环境下下的 在后缀名之后加上 ::$DATA 可以 绕过检查  在\*\*php版本五

如果说不能绕过那可能就是::$DATA被 去除或者加了黑名单  
前者可以双写绕过

示例

\[\[upload1-9.md#3#\]\]

> 一次过滤或者 循环过滤 绕过点和空格的过滤问题  
> 过滤删除后缀名的的代码那么可以重写

### [](#白名单 "白名单")白名单

#### [](#上传html-造成xss "上传html 造成xss")上传html 造成xss

#### [](#htaccess ".htaccess").htaccess

是**apache**的 一个 配置文件  htaccess文件时Apache服务中的一个配置文件，它负责相关目录下的网页配置。通过htaccess文件，可以帮助我们实现：网页301重定向、自定义404错误页面，改变文件扩展名、允许/阻止特定的用户或者目录的访问，禁止目录列表，配置默认文档等功能

例如先上传 .htaccess文件 则

<FilesMatch “.jpg”> SetHandler application/x-httpd-php

将jpg格式文件当成php代码执行  
\*\*注意点必须是一定要在 httpd.conf中找到 allowovertide 设置为allow

#### [](#​-00-编码-和-0x00-十六进制 "​%00  编码  和 0x00 十六进制")​%00  编码  和 0x00 十六进制

\*\*\*原理解释:

了解%00实际上我们要先了解0x00，0x00实际上是一个十六进制表示方式，实际上就是表示ascii码值为0，函数在处理这个字符的时候会把这个字符当做结束符，他们就读取到这里认为这一段结束了。因此如果说我们在进行参数传递使用这个\\0 我们可以截断后面的内容。

\*\*GET传参

直接对应 1.php%00 ，对应解释一下这个get传参的%00是经历过url编码的。

\*\*POST传参

在post数据包后面以十六进制修改0X00

#### [](#​条件竞争 "​条件竞争")​条件竞争

条件竞争，前提是你上传一个文件，文件会保存，但是之后会有格外的操作。例如判断后缀或者是删除修改等。存在一个逻辑安全问题  ,首先已经保存web.jpg了此时后面的又一个文件操作 , 但是如果说我占用这个 web.jpg.此时后面的操作无法进行。但是我就可以一直上传对应的webshell ，然后使用脚本一直进行访问对应的webshell

#### [](#文件解析漏洞 "文件解析漏洞")文件解析漏洞

文件夹类型

Image.asp/1.jpg

那么此时是 1.jpg 按照asp执行

文件类型

1.php:2.jpg

这也是按照php解析

Nginx  1.jpg/1.php

###### [](#二次渲染 "二次渲染")二次渲染

其实针对于,图片解析来讲，如果说我上传了一个图片。他会进行二次的修改和渲染，其实我个人觉得这是一个怎么说呢?这是一个对于有解析漏洞的一个前提。

\*\*解决:

1.  首先上传一张正常的图片，找到对应的保存位置。同时下载对应保存好的图片。
2.  前后两张图片进行比较，找到未渲染的地方(也就是没有修改的地方)，插入我们的木马。
