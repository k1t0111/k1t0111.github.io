---
title: "CORS_跨域资源共享"
date: "2024-09-16"
description: "参考文章:"
---

_**参考文章:**_

[https://xz.aliyun.com/t/12001?time\_\_1311=GqGxRGiti%3Dd052x%2BxCwx7qGIxpbDulE%3DoD](https://xz.aliyun.com/t/12001?time__1311=GqGxRGiti=d052x+xCwx7qGIxpbDulE=oD)  
[https://blog.csdn.net/weixin\_46622976/article/details/128452494](https://blog.csdn.net/weixin_46622976/article/details/128452494)

#### [](#1-跨域资源共享 "1. 跨域资源共享")1\. 跨域资源共享

CORS是为了在**保证安全的前提下**，允许网页从不同域名的服务器请求资源，它实际上是对同源策略的**补充和扩展**。

**CORS**（Cross-Origin Resource Sharing）是一个浏览器的机制，允许服务器在响应中指示哪些源是允许访问其资源的。通过在HTTP响应头中添加特定的CORS头信息（如`Access-Control-Allow-Origin`），服务器能够明确指定哪些外部源可以访问其资源，从而**放宽**同源策略的限制。

一般情况:

*   比如前后端分离的情况，前后端域名不同，但是前端会需要用到后端的接口，发送ajax请求
*   电商网站加载第三方快递网站的物流信息

**CORS的安全性**：CORS实际上通过以下几种方式增强了安全性：

*   只有经过授权的域才能访问资源。
*   可以指定哪些HTTP方法（如GET、POST、PUT等）可以跨域访问。
*   服务器可以控制是否允许带有认证信息（如cookies）的请求。

1.  **简单请求**：
    
    *   当浏览器发出一个跨域请求时，它会首先发送一个**预检请求**（`OPTIONS`请求），询问服务器是否允许该跨域操作。
    *   如果服务器允许，响应中会带有`Access-Control-Allow-Origin`等CORS相关的头，指示浏览器允许该请求继续执行。
2.  **预检请求**：
    
    *   对于某些复杂的跨域请求（如使用了`PUT`、`DELETE`方法或自定义头部），浏览器会先发送一个`OPTIONS`请求，这个请求并不会携带实际数据，仅用于检查服务器是否支持跨域请求。
    *   如果服务器响应允许跨域，浏览器才会继续发送实际的请求。
3.  **允许特定的源**：
    
    *   CORS允许服务器指定允许哪些源（域名、协议、端口）进行跨域请求，而不是让所有源都可以访问资源。这个权限通过设置`Access-Control-Allow-Origin`头来控制。

#### [](#2-请求头判别 "2. 请求头判别")2\. 请求头判别

###### [](#2-1-预检请求 "2.1 预检请求")2.1 预检请求

```shell
OPTIONS /resource HTTP/1.1Origin: https://example.comAccess-Control-Request-Method: POSTAccess-Control-Request-Headers: X-Custom-Header# 响应HTTP/1.1 200 OKAccess-Control-Allow-Origin: https://example.comAccess-Control-Allow-Methods: GET, POST, PUTAccess-Control-Allow-Headers: X-Custom-Header
```

![image.png](https://raw.githubusercontent.com/k1t0111/blog/main/image/20240916210256.png)

Access-Control-Allow-Origin

Access-Control-Allow-Credentials

结果

attack 站点

true

存在漏洞

\*

true

不存在漏洞

null

true

存在漏洞

Null

true

不存在漏洞

*   其中Access-Control-Allow-Origin表示允许跨域访问的host
*   如果想跨域传输cookies,需要Access-Control-Allow-Credentials设置为true，并且需要与XMLHttpRequest.withCredentials 或Fetch API中的Request() 构造器中的credentials 选项结合使用，例如使用`XMLHttpRequest`的时候需要将`withCredentials`的值设置为true

一般都是输入一个origin 查看返回包这两个响应头的情况去判定有无这个漏洞。

##### [](#2-2-身份验证 "2.2  身份验证")2.2 身份验证

CORS（跨源资源共享）允许浏览器进行跨域请求，但对于涉及cookie、HTTP认证等敏感数据的请求，浏览器会有额外的限制。默认情况下，跨域请求不会携带cookie，除非在请求中显式地配置。

##### [](#csrf和cors "csrf和cors")csrf和cors

同源策略挡不住csrf，因为csrf是需要带上cookie的。但是csrf的一些防护策略，对于cors是适用的，因为对于csrf来讲，cookie的授权凭据才是最重要的，而并非是同源策略。因此针对于origin进行过滤，samesite，csrf token ，双重身份验证都是对于防护cors非常有用的。这一点可以参考我的 csrf 防护\[\[渗透测试/top10以及常见漏洞/csrf#​防御策略\]\]

##### [](#防护 "防护")防护

*   Access-Control-Allow-Origin不应该设置为null，也不建议设置为\*，做好设置成受信的站点
*   Access-Control-Allow-Methods的值可以控制尽量少一些，只留需要用到的请求方法
