---
title: "activity"
date: "2024-10-20"
description: "Activity 是 Android 应用的一个单独的屏幕，相当于一个窗口或页面。每个 Activity 通常都对应着一个用户界面（UI），并且是用户与应用程序交互的入口点。"
---

#### [](#what "what")what

##### [](#Activity-的基本概念 "Activity 的基本概念")Activity 的基本概念

**Activity** 是 Android 应用的一个单独的屏幕，相当于一个窗口或页面。每个 Activity 通常都对应着一个用户界面（UI），并且是用户与应用程序交互的入口点。

*   **Activity 的生命周期**：Activity 有一套预定义的生命周期方法，用于管理它的创建、显示、暂停和销毁状态。
*   **每个应用至少有一个 Activity**：通常，应用的主界面就是一个 Activity。当你打开一个应用时，系统会启动该应用的第一个 Activity。

#### [](#Activity-的生命周期 "Activity 的生命周期")Activity 的生命周期

理解 **Activity 的生命周期** 对于管理应用资源、避免内存泄漏和优化用户体验非常重要。下面是 Activity 生命周期的主要方法及其用途：

1.  **onCreate()**：Activity 被创建时调用。你通常会在这个方法中初始化用户界面和设置一些初始数据。
    
2.  **onStart()**：Activity 即将对用户可见时调用。
    
3.  **onResume()**：Activity 开始与用户交互时调用，应用进入“前台”。
    
4.  **onPause()**：Activity 即将离开前台（例如，用户切换到另一个应用时）调用。你可以在这里保存数据或停止动画等。 最主要是我们要知道我们此时还是能在前台看见app，我们依旧可见。
    
5.  **onStop()**：Activity 不再可见时调用，可能被销毁或切换到后台。
    
6.  **onDestroy()**：Activity 被销毁时调用，通常是当用户关闭应用或系统资源不足时。
    

##### [](#周期调用 "周期调用")周期调用

```java
Log.d("ActivityLifecycle", "onDestroy called");这是日志类，我们通过日志类进行调用
```

#### [](#Activity-与任务栈 "Activity 与任务栈")Activity 与任务栈

每个 Activity 都存在于一个任务栈（Task Stack）中。当你启动一个新的 Activity 时，它会被压入栈顶，用户按下返回键时，Activity 会从栈中移除，返回到上一个 Activity。这个机制确保了应用的页面导航顺序。

#### [](#UI-与-Activity-的绑定 "UI 与 Activity 的绑定")UI 与 Activity 的绑定

通常，Activity 会关联一个 **XML 布局文件**，这个文件定义了 Activity 的用户界面。通过 `setContentView()` 方法，你可以将布局文件绑定到 Activity：

```java
@Overrideprotected void onCreate(Bundle savedInstanceState) {    super.onCreate(savedInstanceState);    // 设置 Activity 的布局    setContentView(R.layout.activity_main);}
```

在布局文件中，你定义了按钮、文本框等 UI 元素。通过 **findViewById()**，你可以在 Activity 中访问并操作这些元素：

```java
Button myButton = findViewById(R.id.my_button);myButton.setOnClickListener(new View.OnClickListener() {    @Override    public void onClick(View v) {        // 处理按钮点击事件    }});- **findViewById**：这个方法用于在当前的布局中查找一个视图（比如按钮），你需要传入你想找到的视图的 ID（在这个例子中是 `R.id.my_button`）。    - **R.id.my_button**：这表示在 XML 布局文件中为这个按钮指定的唯一标识符（例如，`res/layout/activity_main.xml`）。    - **类型转换**：因为 `findViewById()` 返回的是一个通用的 `View` 类型，你需要将其转换为 `Button` 类型。在这里，由于你已经将 `myButton` 声明为 `Button` 类型，转换是隐式的（Java 会在知道类型的情况下自动进行转换）。//匿名类- **`myButton.setOnClickListener(...)`**：        - `setOnClickListener` 是 `Button` 类的一个方法，用于设置一个监听器来处理按钮的点击事件。    - 当用户点击这个按钮时，会调用指定的监听器。- **`new View.OnClickListener() {...}`**：        - 这是一个匿名内部类的实现，`View.OnClickListener` 是一个接口，定义了响应点击事件的方法。    - `new View.OnClickListener()` 创建了这个接口的一个实例，并实现了它的方法。- **`@Override`**：        - 这是一个注解，表示接下来的方法是对父类或接口方法的重写。在这里，它表示重写了 `OnClickListener` 接口中的 `onClick` 方法。- **`public void onClick(View v) {...}`**：        - `onClick` 是接口中的方法，当按钮被点击时会被自动调用。    - 参数 `View v` 是被点击的视图的引用，通常在这里可以使用来确定是哪个按钮被点击（如果在同一个活动中有多个按钮）。- **`// 处理按钮点击事件`**：        - 这个注释是指你可以在这个方法体内编写代码，以处理按钮被点击时的逻辑，比如显示一个消息、启动另一个活动、更新 UI 等。
```

> 其实有没有想过一个问题，我们的activity交互和用户交互为什么必须写在周期方法中。因为我们需要一个入口，来把整个程序串起来. 同时我们习惯把东西放在oncreat方法因为一个activity开始的时候我们就可以把所有的一些监听设备都准备好，用户一点击我们就调用。

##### [](#相关控件类 "相关控件类")相关控件类

```java
import android.widget.TextView;Button myButton = findViewById(R.id.button);  TextView myTextView = findViewById(R.id.textView2);
```

#### [](#Activity-之间的跳转与交互 "Activity 之间的跳转与交互")Activity 之间的跳转与交互

> 在应用程序中，你可能会有多个 Activity，用户可以通过不同的页面进行操作。你可以使用 **Intent** 在 Activity 之间跳转和传递数据。

采用最新的跳转方式 ActivityResultLauncher，首先我们模拟从A到B进行操作，

```java
// 从当前 Activity 跳转到另一个 ActivityIntent intent = new Intent(CurrentActivity.this, NextActivity.class);intent.putExtra("key", "hello"); // 发送数据
```

在putExtra参数中 bundle也是一个重要的参数,`Bundle` 是 Android 中一个非常灵活的数据容器，它可以存储多种类型的数据，包括基本数据类型、字符串、甚至其他 `Bundle` 对象或实现了 `Parcelable` 接口的对象。当你需要传递复杂数据结构或者大量数据时，使用 `Bundle` 可以是一个更好的选择。

```java
Bundle bundle = new Bundle();bundle.putString("key1", "value1");bundle.putInt("key2", 123);// ...可以继续添加更多的键值对Intent intent = new Intent(this, TargetActivity.class);intent.putExtras(bundle);activityResultLauncher.launch(intent); // 启动 Activity B  启动B
```

启动B activity之后可以看到在B中，可以设置响应参数

```java
String value = getIntent().getStringExtra("key"); // 处理数据... TextView myTextView1 = findViewById(R.id.textView3); myTextView1.setText(value); // 返回结果给 Activity A Intent returnIntent = new Intent(); returnIntent.putExtra("responseKey", "responseValue"); setResult(RESULT_OK, returnIntent);   // 直接返回 消息 finish(); // 结束 Activity B
```

响应数据根据操作进行接收并且返回

```java
activityResultLauncher = registerForActivityResult(                new ActivityResultContracts.StartActivityForResult(),                result -> {                    // 处理返回结果                    if (result.getResultCode() == RESULT_OK) {                        Intent data = result.getData();                        String response = data != null ? data.getStringExtra("responseKey") : null;                        // 根据响应处理数据                        myTextView1.setText(response);                    }                });  
```

段代码是使用 Android Jetpack 的 `ActivityResultContracts` 类来注册一个 `ActivityResultLauncher`，用于处理另一个 `Activity` 的启动和结果返回。这不仅仅是处理另一个 `Activity` 的响应，它可以用来处理任何启动 `Activity` ForResult 请求的结果

*   **`getIntent().getStringExtra("key")`**：
    
    *   通常在 `onCreate()` 或 `onStart()` 方法中使用。
    *   这个方法用于接收来自启动该 Activity 的 Intent 的数据，通常在 Activity 被创建时就能获取到。
*   **`ActivityResultLauncher`**：
    
    *   这种方法是在启动另一个 Activity 时注册一个结果回调。
    *   当启动的 Activity 结束并返回结果时，回调中的 Lambda 表达式会被执行，这时你可以通过 `result.getData()` 获取返回的 Intent 数据。
