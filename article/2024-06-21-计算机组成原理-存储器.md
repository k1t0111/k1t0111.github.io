---
title: "计算机组成原理_存储器"
date: "2024-06-21"
description: ""
---

![](https://raw.githubusercontent.com/k1t0111/blog/main/image/20240621110440.png)

## [](#存储器构成 "存储器构成")存储器构成

> 材料一般是 半导体 或者磁性材料  
> 存储位元 组成存储单元 组成存储器

#### [](#sram-和dram "sram 和dram")sram 和dram

\*\*\*sram 速度快但是存储单元可能比较复杂因此  
在密度和容量上比不上 存储单元简单的dram

#### [](#基本结构 "基本结构")基本结构

位就要看数据线的多少  
一般来讲存储有地址线 数据线 片选信号 控制线相连接  
地址线决定了 字多少  
1kb=2的10次方 mb gb依次类推  
\*表示为 1k \* 8bit 这个为存储容量

#### [](#字扩展： "字扩展：")字扩展：

将芯片地址、片选和读写控制端相应并联，数据端分别引出  
![image.png](https://raw.githubusercontent.com/k1t0111/blog/main/image/20240608154714.png)

#### [](#位扩展： "位扩展：")位扩展：

将芯片的地址、数据、读写控制线相应并联、片选译码选择相应的片/片组  
![image.png](https://raw.githubusercontent.com/k1t0111/blog/main/image/20240608154727.png)

#### [](#字位扩展： "字位扩展：")字位扩展：

同时进行字扩展位扩展

![image.png](https://raw.githubusercontent.com/k1t0111/blog/main/image/20240608154744.png)

## [](#增加速度 "增加速度")增加速度

### [](#芯片方面 "芯片方面")芯片方面

#### [](#猝发 "猝发")猝发

> 一般来讲 就是访问一个地址时候 如果是需要访问连续的 一行 地址  
> 那么只需要给出一个地址 之后的地址连续 自动跟出进行访问

#### [](#SDRAM-同步dram "SDRAM 同步dram")SDRAM 同步dram

> 其实就是 加了一个时钟 clk 把所有的流程在时钟控制下 进行了 一系列命令的编辑  
> 使得 在处理器 在给出控制信号和地址信号时候可以 更快的获取数据 增加效率

#### [](#CDRAM "CDRAM")CDRAM

> \*\*单纯加了一个高速缓冲寄存器 cache (sram) 因此可以看到一个  
> sram 里面保存了最近的一些数据 如果命中就可以不再访问dram  
> 增加了速度

### [](#结构方面 "结构方面")结构方面

##### [](#并行存储器 "并行存储器")并行存储器

###### [](#双端口存储器 "双端口存储器")双端口存储器

> 个人看法 感觉有点像控制存取的并行 因为它提供了两个端口 一个左端口一个右端口  
> 分别有两个完全一样的 地址总线 数据总线 控制总线  
> 可以增加速度 不过发生冲突时候可能会有busy标志

###### [](#多模块交叉存储器 "多模块交叉存储器")多模块交叉存储器

> 多模块意味着 是多个模块存储器并行 这就涉及到编址方式 一般是 顺序编址和交叉编址  
> 一般就是 意味着 顺序编址 有一种串联 可扩展性 和一种互不干扰性质  
> 相互不干扰可以并行访问极大的增加了效率

### [](#系统结构方面 "系统结构方面")系统结构方面

> cache 虚拟存储器

## [](#cache "cache")cache

#### [](#引入目的 "引入目的")引入目的

> 解决主存和cpu访问速度不匹配的问题

##### [](#流程 "流程")流程

**引入cache后CPU的访问流程**  
当CPU发出读请求时，若访存地址在Cache中命中，就将此地址转换成Cache地址，直接对Cache进行读操作，与主存无关；若Cache不命中，则仍需访问主存，并把此字所在的块一次性地从主存调入Cache。若此时Cache已满，则需根据某种替换算法，用这个块替换Cache中原来的某块信息。整个过程全部由硬件实现。值得注意的是，_**CPU与Cache之间的数据交换以字为单位，而Cache与主存之间的数据交换则以Cache块为单位**_。  
**注意**：某些计算机中也采用同时访问Cache和主存的方式，若Cache命中，则主存访问终止；否则访问主存并替换Cache。  
cache中又一个cam 是一个按照内容寻址的 存储器  
cache 中是一行 每一行固定几个字一般来讲都是从主存拿相邻固定字长的数据进cache

### [](#cache效率 "cache效率")cache效率

1.  \*\*\*命中率

cache次数 n1 和 主存次数n2  
则可以知道命中率 h=n1/n1+n2  
2\. \*\*\*平均时间

这个需要 cache时间Ta和 主存时间Tm 一般是周期  
t=hTa+(1-h)Tm  
3\. \*\*\*效率

n=tc/t

## [](#三种映射方式 "三种映射方式")三种映射方式

#### [](#直接映射 "直接映射")直接映射

![image.png](https://raw.githubusercontent.com/k1t0111/blog/main/image/20240611161121.png)

#### [](#全相联映射 "全相联映射")全相联映射

![image.png](https://raw.githubusercontent.com/k1t0111/blog/main/image/20240611161206.png)

#### [](#组相联映射 "组相联映射")组相联映射

![image.png](https://raw.githubusercontent.com/k1t0111/blog/main/image/20240611161222.png)

## [](#替换算法 "替换算法")替换算法

> 其实就是 你cache 不命中 是不是就要到内存中 去找数据  
> 因此就在这里我们就需要设计算法 去替换cache

##### [](#最不经常使用LFU： "最不经常使用LFU：")最不经常使用LFU：

将一段时间内被访问次数最少的存储行换出 每一行一个计数器 被访问加一

##### [](#近期最少使用LRU： "近期最少使用LRU：")近期最少使用LRU：

选择近期内长久未访问的块进行替换 每一行一个计数器 被访问 清零其他加一

##### [](#随机替换 "随机替换")随机替换

##### [](#先进先出FIFO：选择最早调入的块进行替换 "先进先出FIFO：选择最早调入的块进行替换")先进先出FIFO：选择最早调入的块进行替换

### [](#保证一致性 "保证一致性")保证一致性

\*\*写回法：修改时不立即写回主存，只有当此块被换出时才写回主存  
全写法：当CPU对Cache写命中时，必须把数据同时写入Cache和主存（需要写缓冲）

## [](#虚拟存储器 "虚拟存储器")虚拟存储器

> 首先简单介绍一下虚拟存储器 , 一般来讲 程序 需要的 主存的大小可能远大于或者小于 主存  
> 因此对于存储器来讲 ,我们会有一个虚拟空间 我们可以根据虚拟空间 编写虚拟地址  
> 存在辅存中, 程序运行时候可以看到虚拟地址会有地址转换

#### [](#页表 "页表")页表

> 可以看到 页表 其实就是用来进行地址转换的 页表里面 分页面  
> 页面分为 逻辑页面和 物理页面 一般来讲 分为高字段 字号和低字段的 页内地址  
> 因此可以看到就是一个转换

> \*\*\*一般一个进程一个页表 因此可能会很大 所以  
> 、

\*\*相关存储方式

1.  主存和辅存都保留
2.  反向页表
3.  二级页表类似目录一般

##### [](#TLB "TLB")TLB

> \*转换后援缓冲器 快表 一般是用来 类似于 cache 的作用 一般就是  
> 将一些经常访问的东西都 存在快表增加时间

#### [](#转换步骤 "转换步骤")转换步骤

![image.png](https://raw.githubusercontent.com/k1t0111/blog/main/image/20240613161336.png)

\*\*\*页表基地址 寄存器

\*\*逻辑页号作为数组的下表可以得到物理页号因此 可以指将 物理页号与一个页内地址拼接找到物理地址

#### [](#替换算法-1 "替换算法")替换算法

> 和cache一样

#### [](#cache和-虚拟存储器 "cache和 虚拟存储器")cache和 虚拟存储器

![image.png](https://raw.githubusercontent.com/k1t0111/blog/main/image/20240613162046.png)

### [](#主存编址 "主存编址")主存编址

![2d8750e27c91702fc6f6415f6c34936b.jpg](https://raw.githubusercontent.com/k1t0111/blog/main/image/2d8750e27c91702fc6f6415f6c34936b.jpg)

![e9ad2a976c03ba68c0c079abc1eb9b81.jpg](https://raw.githubusercontent.com/k1t0111/blog/main/image/e9ad2a976c03ba68c0c079abc1eb9b81.jpg)
